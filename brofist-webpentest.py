import paramiko
import xmltodict
import json, StringIO, datetime
import re, os, json, sys, logging
from collections import OrderedDict
from flask import Flask, render_template, request, session, abort, redirect, send_file
import glob

###########################
# IMPORT MODULE on SCRIPT #
###########################

sys.path.append("script")
from dsp_api import LST_PTSELSRV, LST_PTSELSUB, LOGIN, LOGIN_TB, LOGOUT, GET_SUBDATA, RMV_PTSELSRV, RMV_PTSELSUB, ADD_PTSELSRV
from ingw_api import OCSBALANCE, OCSBONUS
from ssr_api import SSRSEARCH, SSRKILL
from upcc_api import LST_PTSELSRV_API, GETCONFUPCC, GET_SUBALL_API, RMV_PTSELEAI_API, LST_GRPMBR_API, LST_GRPMBRLST_API, RMV_SUBSRV_API, ADD_SUBSRV_API, ADD_PTSELEAI_API
from locsearch import LOCSEARCH
from galsearch import GALSEARCH
from ssrparser import start_parsing_epg, sdfsearch, acgsearch
from upccparser import processingFile
###########################

import logging
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

app = Flask(__name__)

list_itcsm = ['diakbar', 'linthonori', 'ajimangun', 'jokowib']
def parsingWebAccess():
    fileAcc = open("access.txt","r")
    accDict = {}
    for line in fileAcc:
        if not line.strip():
            continue
        line_splt = line.split(" ")
        username = line_splt[0].strip()
        password = line_splt[1].strip()
        accDict[username] = password
    return accDict

def validate(username, password):
    accDict = parsingWebAccess()
    print("try validate user "+username+" pass "+password)
    try:
        password_dict = accDict[username]
        print("password: "+password)
        print("password dict: "+password_dict)
        if password_dict == password:
            print("okay same, password_dict"+password_dict+" password:"+password)
            print session
            session['authenticated'] = True
            session['username'] = username
            if username in list_itcsm:
                session['itcsm'] = True
            print session['username']
            print("done validate")
    except Exception as e:
        err_text = {}
        err_text['Error'] = 'User Not Exist! Err:'+str(e)
        print 'User Not Exist! Err:'+str(e)
        return err_text

@app.route('/')
def index():
    if not session.get('authenticated'):
        return render_template('login.html')
    else:
        # print("recall index.html")
        epg_file_date = dict_epg_conf['LAST_UPDATE_CONF']
        epg_hostname = dict_epg_conf['HOSTNAME']
        upcc_version = dict_upcc_conf['UPCCVER']
        upcc_fileinfo = dict_upcc_conf['UPCCVER']
        return render_template('index.html', epg_file_date=epg_file_date, epg_hostname=epg_hostname, upcc_version = upcc_version, upcc_fileinfo = upcc_fileinfo)

@app.route('/login',methods=['POST','GET'])
def do_admin_login():
    try:
        if request.method == "POST":
            validate(request.form['username'], request.form['password'])
            print session
            print("try return to index")
            return redirect("/", code=302)
    except Exception as e:
        print("erorny",str(e))
        return redirect("/", code=302)

@app.route('/logout',methods=['POST','GET'])
def do_admin_logout():
    try:
        if request.method == "POST":
            session.clear()
            # print session
            # print("try return to index")
            return redirect("/", code=302)
    except Exception as e:
        print("erorny",str(e))
        return redirect("/", code=302)

@app.route('/upccprov',methods=['POST'])
def upccprov():
    # print("got",request.method,)
    # print xmltodict.parse(request.data)['xml']['From']
    try:
        # if request.method == 'POST' and session.get('authenticated'):
        if request.method == 'POST':
            _msisdn = request.form['msisdn']
            _server = request.form['server']
            _option = request.form['option']
            list_whitelist_username = ['diakbar', 'ajimangun', 'jokowib']
            print("msisdn",_msisdn)
            print("server",_server)
            print("option",_option)
            # soap_response, sesi = LOGIN()
            # print("got response DSP",soap_response,sesi)
            # return LST_PTSELSUB(login_resp=soap_response, sesi=sesi, msisdn=msisdn, opsi="return_xml", proxy=True)
            if _option == 'LST_PTSELSRV':
                return LST_PTSELSRV_API(msisdn=_msisdn,option="return_xml",server=_server)

            elif _option == 'RMV_PTSELSRV':
                _profile = request.form['profile']
                # if _server == "production":
                #     soap_response, sesi = LOGIN(proxy=True)
                # else                #     soap_response, sesi = LOGIN_TB(proxy=False)

                # status_code, status_desc = RMV_PTSELSRV(login_resp=soap_response, sesi=sesi, msisdn=_msisdn, profile=_profile, opsi="return_default", proxy=True)
                # soap_url = soap_response.headers['Location']
                # LOGOUT(sesi=sesi, url_logout=soap_url)
                status_code, status_desc = RMV_PTSELEAI_API(msisdn=_msisdn, profile=_profile, option = 'return_status_code', server=_server, debug=False)
                return_text = {'status_code': str(status_code), 'status_desc': str(status_desc)}
                return json.dumps(return_text)

            elif _option == 'GET_SUBALL':
                print("GET_SUBALL")
                return_text = GET_SUBALL_API(msisdn=_msisdn,option="return_dict",server=_server,debug=False)
                return json.dumps(return_text)

            elif _option == 'ADD_PTSELEAI' and session.get('authenticated'):
                if session['username'] not in list_whitelist_username:
                    return json.dumps({'status_code':'FXFXFX', 'status_desc':'username '+session['username']+'not allowed'})
                print("ADD_PTSELEAI")
                _profile = request.form['profile']
                _priority = request.form['priority']
                _quota_name = request.form['quota_name']
                _quota_value = request.form['quota_value']
                _quota_description = request.form['quota_description']
                _subscription_date = request.form['subscription_date']
                _start_date = request.form['start_date']
                _end_date = request.form['end_date']
                _quota_threshold = request.form['quota_threshold']
                _quota_interval = request.form['quota_interval']
                _slice_volume = request.form['slice_volume']
                status_code, status_desc = ADD_PTSELEAI_API(
                          msisdn=_msisdn,
                          profile=_profile,
                          priority=_priority,
                          quota_name=_quota_name,
                          quota_description=_quota_description,
                          start_date=_start_date,
                          end_date=_end_date,
                          subscription_date=_subscription_date,
                          quota_value=_quota_value,
                          quota_threshold=_quota_threshold,
                          quota_interval=_quota_interval,
                          slice_volume=_slice_volume,
                          option='return_status_code',
                          debug=True,
                          server=_server)
                return json.dumps({
                    'status_code': status_code,
                    'status_desc': status_desc,
                    })

            elif _option == 'LST_GRPMBR':
                print("LST_GRPMBR")
                return_text = LST_GRPMBR_API(
                    msisdn=_msisdn,
                    option="return_dict",
                    debug=True,
                    server=_server
                    )
                return json.dumps(return_text)

            elif _option == 'LST_GRPMBRLST':
                print("LST_GRPMBRLST")
                return_text = LST_GRPMBRLST_API(
                    msisdn=_msisdn,
                    option="return_dict",
                    debug=True,
                    server=_server
                    )
                return json.dumps(return_text)
        else:
            return "not authenticated", 999
    except Exception as e:
        print str(e)
        return_text = {'status_code': "ErrException", 'status_desc': str(e)}
        return json.dumps(return_text)
    if request.method == 'GET':
        return "Error Page Not Found"

@app.route('/ingwapi',methods=['POST','GET'])
def ingwapi():
    # print("got",request.method,)
    # print xmltodict.parse(request.data)['xml']['From']
    try:
        if request.method == 'POST':
            _msisdn = request.form['msisdn']
            _opsi_ingw = request.form['opsi_ingw']
            # print("msisdn",_msisdn,"opsi_ingw",_opsi_ingw)
            if _opsi_ingw == 'ocsbalance':
                return OCSBALANCE(msisdn=_msisdn,option="return_json")
            if _opsi_ingw == 'ocsbonus':
                # print("ocsbonus entered!")
                return OCSBONUS(msisdn=_msisdn,option="return_json")
        # return "hahaha",request.form
    except Exception as e:
        # print str(e)
        pass
    if request.method == 'GET':
        return "Error Page Not Found"

@app.route('/dspquery',methods=['POST','GET'])
def dspquery():
    try:
        if request.method == 'POST':
            _msisdn = request.form['msisdn']
            print("msisdn",_msisdn)
            if "628" not in _msisdn:
                print("wah ",_msisdn,"ga nomor coba cari galsearch")
                _msisdn = GALSEARCH(_msisdn.strip().split(), opsi="return_msisdn")
                _msisdn = re.sub(r'^0','62',_msisdn)
                print("msisdnnya "+_msisdn)

            DSP_INFO = {}
            if _msisdn != "" or _msisdn != None:
                text, longitude, latitude = LOCSEARCH(msisdn=_msisdn, opsi="return_text_longlat")
                DSP_INFO['LONGITUDE']  = longitude
                DSP_INFO['LATITUDE'] = latitude
                DSP_INFO['DETAILS'] = text
                if longitude == "":
                    return "Not Found",500
                try:
                    address = gmapsearch(longitude=longitude, latitude=latitude, option="return_address")
                except Exception as e:
                    address = ''
                DSP_INFO['ADDRESS'] = address
                return json.dumps(DSP_INFO)
            else:
                return json.dumps("Error MSISDN input "+str(_msisdn)),500
        elif request.method == 'GET':
            resp_server = {
                'ResultCode': '',
                'ResultDesc': ''
            }
            print("got req args for bot",request.args)
            tgl = str(datetime.datetime.now().strftime('%Y%m%d'))

            try:
                secret = request.args.get('secret')
                msisdn = request.args.get('msisdn') # -1001103624032
                if secret == 'AnakTikTok123':
                    soap_response, sesi = LOGIN(proxy=True)
                    return_dict = GET_SUBDATA(login_resp=soap_response, sesi=sesi, msisdn=msisdn, opsi="return_json", proxy=True)
                    soap_url = soap_response.headers['Location']
                    LOGOUT(sesi=sesi, url_logout=soap_url)
                    bot = list_bot['logtselbot']
                    chat_id = "23736629"
                    ip_client = request.remote_addr
                    print("got request from:"+ip_client)
                    bot.sendChatAction(chat_id=chat_id, action=telegram.ChatAction.TYPING)
                    msg = '[web] command dari '+ip_client+' dengan msisdn '+msisdn
                    try:
                        resp_bot = bot.sendMessage(chat_id=chat_id, text="`"+msg+"`", parse_mode="MARKDOWN", timeout=15)
                    except Exception as e:
                        resp_server['status_code'] = "FFFF"
                        resp_server['status_desc'] = "ErrException:"+str(e)
                        return json.dumps(resp_server)
                    return json.dumps(return_dict)
                else:
                    resp_server['ResultCode'] = "HEHE"
                    resp_server['ResultDesc'] = "Wrong Secret:"+secret
                    return json.dumps(resp_server)
                
            except Exception as e:
                resp_server['ResultCode'] = "FFFF"
                resp_server['ResultDesc'] = "Incorrect input:"+str(e)
                return json.dumps(resp_server)
        # return "hahaha",request.form
    except Exception as e:
        print str(e)
        return json.dumps("ErrorException: "+str(e)),500

@app.route('/ssrsearch',methods=['POST','GET'])
def ssrsearch():
    try:
        if request.method == 'POST':
            _msisdn = request.form['msisdn']
            _epg = request.form['pcef']
            print("Got POST with data: msisdn "+_msisdn+", pcef "+_epg)
            try:
                result = SSRSEARCH(msisdn=_msisdn, ggsn=_epg)
            except Exception as e:
                print("SSH connection to BASTION server is down, restarting again! Err:"+str(e))
                return json.dumps("Cannot connect to Bastion Server. Err:"+str(e)), 500

            return result

    except Exception as e:
        print str(e)

@app.route('/ssrkill',methods=['POST','GET'])
def ssrkill():
    try:
        if request.method == 'POST':
            _msisdn = request.form['msisdn']
            _epg = request.form['pcef']
            # print("Got POST with data: msisdn "+_msisdn+", pcef "+_epg)
            try:
                result = SSRKILL(msisdn=_msisdn, ggsn=_epg)
            except Exception as e:
                return json.dumps("Cannot connect to Bastion Server. Err:"+str(e)), 500

            return json.dumps(result)
    except Exception as e:
        return json.dumps(str(e))

@app.route('/confupcc',methods=['POST','GET'])
def confupcc(service=None):
    try:
        if request.method == "POST":
            _option = request.form['option']
            if _option == 'quota2service':
                _quota_name = request.form['param']


                list_service = QUOTA2SERVICE[quota]
                # print QUOTA2SERVICE
                result = OrderedDict({
                    'quota_name': quota,
                    'list_service': list_service
                    })

            return json.dumps(result)
    except Exception as e:
        # print("erorny",str(e))
        err_text = {}
        err_text["error"] = str(e)
        return json.dumps(err_text)
        # raise e
    return "Error Page Not Found"

# def UGWSEARCH(msisdn, host_ugw):
#     list_ugw = """
#     GGHRM1:10.77.113.1
#     GGHRM2:10.77.113.4
#     GGSBY1:10.60.100.1
#     GGSBY2:10.60.100.4
#     """

#     dict_ugw = {}

#     for line in list_ugw.splitlines():
#         if not line.strip():
#             continue
#         # print line.strip().split(":")
#         splt_line = line.strip().split(":")
#         hostUGW = splt_line[0]
#         ipServerUGW = splt_line[1]
#         dict_ugw[hostUGW] = ipServerUGW

#     ipServerUGW = dict_ugw[host_ugw.upper()]
#     sshcmdUGW = paramiko.SSHClient()
#     sshcmdUGW.set_missing_host_key_policy(paramiko.AutoAddPolicy())
#     sshcmdUGW.connect(ipServerUGW, username=userUGW, password=passUGW)
#     ugwChan = sshcmdUGW.invoke_shell()
#     buff = ''
#     while not buff.endswith('>'):
#         resp = ugwChan.recv(9999)
#         buff += resp
        
#     ugwChan.send('display pdpcontext msisdn '+msisdn+'\n')
#     buff = ''
#     while not buff.endswith('>'):
#         resp = ugwChan.recv(9999)
#         resp = resp.replace("  ---- More ----","").replace('[42D                                          [42D','')
#         buff += resp
#         ugwChan.send('\n')

#     dict_out_ugw = OrderedDict()
#     for line in buff.splitlines():
#         if "The PDP Context does not exist!" in line:
#             dict_out_ugw['Error'] = line.strip()
#             print json.dumps(dict_out_ugw)
#             return 300
#         if "=" in line:
#             line_splt = line.strip().split("=")
#             par = line_splt[0]
#             val = line_splt[1]
#             dict_out_ugw[par] = val
#     return json.dumps(dict_out_ugw)

if __name__ == '__main__':
    dict_epg_conf = start_parsing_epg(inputfile='ericsson.cfg')
    dict_upcc_conf = processingFile(inputfile='latest-upcc.conf')

    QUOTA2SERVICE = {}
    for service in dict_upcc_conf['SERVICEQUOTA']:
        list_quota = dict_upcc_conf['SERVICEQUOTA'][service]
        for quota in list_quota:
            # print quota
            if quota not in QUOTA2SERVICE:
                # print quota, service
                QUOTA2SERVICE[quota] = [service]
                # print QUOTA2SERVICE
            else:
                QUOTA2SERVICE[quota].append(service)

    app.secret_key = os.urandom(12)
    app.run(debug=True, host='0.0.0.0', port=1337, threaded=True, use_reloader=False)
